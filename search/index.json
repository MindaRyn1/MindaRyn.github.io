[{"content":"单链表的概念 任何数据结构的基础都是创建+增删改查，由这几个操作可以构造很多算法题，所以我们也从这五项开始学习链表。\n什么是链表\r首先看一下什么是链表？使用链表存储数据，不强制要求数据在内存中集中存储，各个元素可以分散存储在内存中。例如，使用链表存储 {4，,15，,7，,40}，各个元素在内存中的存储状态可能是：如下图：\r创建链表 JVM 里有栈区和堆区，栈区主要存引用，也就是一个指向实际对象的地址，而堆区存的才是创建的对象，例如我们定义这样一个类：\n1 2 3 4 public class Course{ int val; Course next; } 这时候 next 就指向了下一个同为 Course 类型的对象了，例如： 这里通过栈中的引用（也就是地址）就可以找到 val(1)，然后 val(1)结点又存了指向 val(2)的地址，而 val(3)又存了指向 val(4)的地址，所以就构造出了一个链条访问结构。\nJava 规范的链表定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class ListNode{ private int data; private ListNode next; public ListNode(int data){ this.data = data; } public int getData() { return data; } public void setData(int data) { this.data = data; } public ListNode getNext() { return next; } public void setNext(ListNode next) { this.next = next; } } LeetCode 中的链表定义 1 2 3 4 5 6 7 8 9 public class ListNode{ private int val; private ListNode next; ListNode(int x){ val=x; next=null; } } ListNode listnode = new ListNode(1); 创建对象后能直接使用 listnode.val 和 listnode.next 来操作\n链表的增删改查 遍历链表 对于单链表，不管进行什么操作，一定是从头开始逐个向后访问，所以操作之后是否还能找到表头非常重要。一定要注意\u0026quot;狗熊掰棒子\u0026quot;问题，也就是只顾当前位置而将标记表头的指针丢掉了。\n1 2 3 4 5 6 7 8 9 public static int getListLength(Node head){ int length = 0; Node node = head; while(node != null){ length++; node = node.next; } return length; } 链表插入 插入操作需要要考虑三种情况：首部、中部和尾部\n在链表的表头插入 在链表中间插入 在单链表的结尾插入结点 完整实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * 链表插入 * @param head 链表头节点 * @param nodeInsert 待插入节点 * @param position 待插入位置，从1开始 * @return 插入后得到的链表头节点 */ public static Node insertNode(Node head, Node nodeInsert, int position) { if (head == null) { //这里可以认为待插入的结点就是链表的头结点，也可以抛出不能插入的异常 return nodeInsert; } //已经存放的元素个数 int size = getLength(head); if (position \u0026gt; size+1 || position \u0026lt; 1) { System.out.println(\u0026#34;位置参数越界\u0026#34;); return head; } //表头插入 if (position == 1) { nodeInsert.next = head; head = nodeInsert; return head; } Node pNode = head; int count = 1; //这里position被上面的size被限制住了，不用考虑pNode=null while (count \u0026lt; position - 1) { pNode = pNode.next; //从head开始遍历，找到目的节点 count++; } nodeInsert.next = pNode.next; pNode.next = nodeInsert; return head; } 链表删除 删除操作也需要要考虑三种情况：首部、中部和尾部\n在链表的表头删除 在单链表的结尾删除 在单链表的中部删除结点 完整实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 删除节点 * @param head 链表头节点 * @param position 删除节点位置，取值从1开始 * @return 删除后的链表头节点 */ public static Node deleteNode(Node head, int position) { //判断链表是否空 if (head == null) { return null; } int size = getListLength(head); //思考一下，这里为什么是size，而不是size+1（链表最长为size,删除不了size+1的结点） if (position \u0026gt; size || position \u0026lt;1) { System.out.println(\u0026#34;输入的参数有误\u0026#34;); return head; } if (position == 1) { //curNode就是链表的新head return head.next; } else { Node cur = head; int count = 1; while (count \u0026lt; position - 1) { cur = cur.next; //从head开始遍历，找到目的节点 count++; } Node curNode = cur.next; cur.next = curNode.next; //上面两行可以直接简化成：cur.next=cur.next.next } return head; } 问题 1.理解 Java 是如何构造出链表的\n2.链表增加元素，首部、中间和尾部分别会有什么问题，该如何处理？ 3.链表删除元素，首部、中间和尾部分别会有什么问题，该如何处理？\n4.双向链表是如何构造的，如何实现元素的插入和删除。\n","date":"2023-10-16T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E9%93%BE%E8%A1%A8/","title":"链表"},{"content":"操作系统的基本原理 操作系统可以看作是人机交互的接口\n进程的状态 等待态：没有充足资源，没有 CPU 资源\r就绪态：资源充足+缺 CPU\r运行态：资源充足+CPU 资源\r活跃阻塞=等待态 静止阻塞:都缺，但人为挂起 静止就绪: 不缺资源，但人为挂起\nPV 操作 加入 pv 操作：并发进程操作时加阻塞防止溢出\n死锁 系统在某个时刻所有的可用的资源都分配出去，所有的进程都等待着其他进程放资源而阻塞，造成死锁\n索引文件结构 直接索引：4k* 10 1 级间接索引：4k* 1024 2 级间接索引：4k* 10242 3 级间接索引：4k* 10243 间接的级别越高，访问效率越低\n数据传输方式 是指内存和外设之间的数据传输问题 程序控制方式 最低级也是 CPU 介入最多的方式，外设处于被动，由 CPU 发出查询指令，查询是否传输成功 程序中断方式当完成传输时，会产生中断，提高效率 DMA 方式 直接存取控制，有 DMA 控制器控制外设与内存的数据传输\n微内核 单体内核 减少系统开销，但系统庞大，占用资源多，系统稳定性差 微内核 内核精炼，便于移植，系统可靠性，安全性和稳定性高，可用于分布式系统，因需要频繁切换内核和用户态，效率相对较低。\n","date":"2023-10-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"操作系统"},{"content":"常用的数据结构 数组、链表、队、栈、Hash、集合、树、堆。\n常用的算法思想 查找、排序、双指针、递归、迭代、分治、贪心、回溯和动态规划等等\n","date":"2023-10-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","title":"常见的数据结构与算法"},{"content":"CPU 结构 CPU 组成：由运算器、控制器、寄存器组（读取速度最快）、内部总线组成\n运算器组成: 算数逻辑单元 ALU(Arithmetic logic unit): 实现对数据的算数和逻辑运算\n累加寄存器 AC(Accumulator): 提供数据并暂存运算结果\n数据缓冲寄存器 DR(Data Register): 作为 CPU 和内存、外设之间数据传送的中转站，暂时存放内存的指令或数据\n状态条件寄存器 PSW(Program Status Word): 保存指令运行结果相关的标志位，如中断或进位等标志\n控制器 指令寄存器 IR （ Instruction Register ） : 暂存当前 CPU 正在执行的指令【操作码和地址码在这里存储】对于用户是透明的\n程序计数器 PC （ Program Counter ）： 用于存放下一条指令的地址\n地址寄存器 AR （ Address Register ）： 保存当前 CPU 所访问的内存地址\n指令译码器 ID （ Instruction Decoder）： 分析指令操作码\n计算机体系结构分类\u0026ndash;Flynn SISD 单片机 SIMD 并行，阵列处理（对数组操作）\nMISD 理论模型 MIMD 个人 pc，计算机系统\nCISC 与 RISC CISC 计算机不发达时期的产物，指令多，复杂 RISC 现代计算机，指令少，复杂度低，引入了寄存器，效率高\n存储结构 计算机层次存储结构 引入cache的原因：存在局部性原理 Cache 和 CPU 交互反交互的时候，暂停和内存的交互，速度就会很快。引入 cache 在提高速度的同时，也没有增加多少成本 局部性原理 时间局部性:刚刚访问完数据又立即访问，不需要等待。 空间局部性:例如数组的初始化处理，在将数组初始化的过程中，初始化完这一个位置后立即去初始化下一个临近的空间。 工作集原理:工作即是进程，运行时被频繁访问的页面集合。将这些集合打包放进 Cache 里面去，就不需要频繁的替换掉。 主存储器 主存的分类 随机存取存储器： DRAM 动态 RAM,SRAM 静态 RAM（断电后无法写入保存数据）\n只读存储器： MROM,PROM,EPROM,flash memory（断电后依然可以写入保存数据）\n磁盘工作原理 总线系统 内部总线 通常是指微机内部的，外部芯片与处理器之间的联系，属于是芯片级别的总线 系统总线 属于是微机中各个插件板与系统之间的总线，属于是插件板级别的总线，如 PCI，VGA 数据总线:是用来传输数据的，比如说计算机的 32 位和 64 位，说明了系统总线的宽度就是这么个位数，那么一个周期能够传输的数据是 32164bit。 地址总线:若地址总线的位数是 32 位，那么它代表的地址总线宽度为 2^32，即 4G。因此操作系统是 32 位的，那么他能管理的内存最多是 4g，当然也有硬件有一定关系。 控制总线: 发送相应的控制信号的总线。 外部总线 属于是外部设备的总线。 ","date":"2023-10-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/","title":"计算机结构"},{"content":"OSI/RM 七层模型 网络技术标准与协议 TCP/IP 协议又称重量协议 IPX/SPX 协议（局域网协议） TCP 三次握手协议（可靠，有验证 ） DNS 协议\n递归查询：目标 ip 与域名 1 对 1 迭代查询：目标 ip 与域名的关系，可以是 1 对多 计算机网络分类-拓扑结构 特殊的 IP 地址 ","date":"2023-10-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络"},{"content":"数据编码 若用 1 个字节也就是 8bit 来存放数据 最高位为符号位 0 为正数，1 为负数 原码不能直接运算（eg，1-1） 反码的正数与原码相同，负数符号位不变，其他位置按位取反 补码的正数与反码相同，其他位不变，在反码的末位+1 移码在补码的基础上，把首位取反，（移码中 0 为负数，1 为正数） 以 8bit 为例 原码范围为 -(28-1-1)~(28-1-1) 范围：-127~127 反码范围为 -(28-1-1)~(28-1-1) 范围：-127~127 补码范围为 -(28-1-1)~(28-1-1) 范围：-128~127（补码因进位表示，故多一位） 浮点数运算 注意使用科学计数法 N = M * Re\n","date":"2023-10-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA/","title":"数据的表示"},{"content":"三级模式 数据库设计过程 E-R 模型 实体与关系模式 1 对 1——至少有两种关系模式 1 对 多——职工与部门 多对多——学生与课程\n键 超键与候选键的区别：超键存在冗余\n范式 1NF 只包含原子值，每一个分量都是不可再分的数据项 2NF 当且仅当 R 是 1NF,且每一个非主属性完全依赖主键(不存在部分函数依赖) 3NF 当且仅当 R 是 2NF,且 E 中没有非主属性传递依赖于码(不存在部分函数依赖) BCNF E 中每个依赖关系必定包含 E 的某个候选关键字 存在问题：数据冗余，插入异常，删除异常，更新异常\n并发控制 事务 把操作封装起来，看作一个整体，这些操作同时完成或同时失败。 可能出现的问题：\n丢失更新 不可重复读 读“脏”数据 解决办法\n一级封锁协议：事务 T 在修改数据 R 之前必须先对其加 X 锁，防止丢失修改 二级封锁协议：一级封锁协议加上事务 T 在修改数据 R 之前对其加 S 锁,读完后释放 S 锁，防止读“脏”数据 三级封锁协议：一级封锁协议加上事务 T 在修改数据 R 之前对其加 S 锁,事务结束才释放 S 锁，防止数据重复读 数据库安全 数据库备份与恢复 分类方式一 备份方式 特点 优点 缺点 冷备份(静态备份) 在数据库正常关闭的状态下将数据库的文件全部备份 速度快 不能按表或用户恢复 热备份(动态备份) 在数据库正常运行的状态下将数据库的数据文件备份 可实现恢复某一时间点恢复 不能出错 分类方式二 完全备份 备份所有数据 差量备份 仅备份上次完全备份后变化的数据 增量备份 备份上传备份后变化的数据\n静态海量转储 系统无运行事务时，转储全部数据库 动态海量转储 系统运行事务时，转储全部数据库 静态增量转储 系统无运行事务时，转储上次更新的数据 动态增量转储 系统运行事务时，转储上次更新的数据 ","date":"2023-10-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/","title":"数据库系统"},{"content":"记录写博客的第二天 天气：晴\n心情：开心\n今日歌曲 ","date":"2023-09-16T13:48:38+08:00","permalink":"https://MindaRyn1.github.io/p/%E6%97%A5%E8%AE%B002/","title":"日记02"},{"content":"记录写博客的第一天 天气：晴\n心情：开心\n引用 你是春日里吹来花信的风 是夏夜里倒悬的星河 星辰交替，季节更迭 唯我对你的欢喜不变\n图片 ","date":"2023-09-15T13:48:38+08:00","image":"https://MindaRyn1.github.io/p/%E6%97%A5%E8%AE%B001/01_hu7639071ad9a5d8c1c64845759a34708c_878250_120x120_fill_q75_box_smart1.jpg","permalink":"https://MindaRyn1.github.io/p/%E6%97%A5%E8%AE%B001/","title":"日记01"},{"content":"数据结构 什么是数据结构 数据结构:是相互之间存在的一种或多种特定关系的数据元素的集合\n逻辑结构与物理结构 按照视点的不同 把数据结构分为逻辑结构和物理结构。\n逻辑结构 数据对象中数据元素之间的相互关系\n集合结构中的元素同属于同一个集合，之间没有任何关系，各个数据元素是“平等的”\n线性结构中的数据元素是一对一的关系\n树形结构中的数据元素存在一对多的层次关系\n图形结构的数据元素是多对多的关系\n物理结构 逻辑结构在计算机的存储形式\n顺序存储结构 数据元素存放在地址相同的存储单元 数据间逻辑关系和物理关系一致 链式存储结构 数据元素存放在任意的存储单元 存储单元可以是连续也可以不连续 时间复杂度 时间复杂度的时间指的是用语句的执行次数，而不是实际的时间。我们知道计算机执行乘除运算是非常消耗资源的，而加减则计算很快，时间复杂度只是一个简化的描述。\n常见的阶耗费时间的关系是: 时间复杂度练习 设 n 为正整数，试确定下列各程序段中前置以记号@的语句的频度\n第一题\n1 2 3 4 5 6 7 8 x=91; y=100; while(y\u0026gt;0) { @ if(x\u0026gt;100) { x -= 10; y--; } else x++; 第二题\n1 2 3 4 5 6 7 i=1; j=0; while(i+j\u0026lt;=n) { @ if(i\u0026gt;j) j++; else i++; } 第三题\n1 2 3 4 x=n; y=0; while(x\u0026gt;=(y+1)*(y+1)) { @ y++; } 第四题\n1 2 3 4 5 k=0; for(i=1; i\u0026lt;=n; i++) { for(j=i; j\u0026lt;=n; j++) @ k++; } 第五题\n1 2 3 4 5 for(i=1; i\u0026lt;=n; i++) { for(j=1; j\u0026lt;=i; j++) { for(k=1; k\u0026lt;=j; k++) @ x += delta; } 答案：\n$$ 1100$$ $$n$$ $$\\sqrt{n}$$ $$\\frac{n(n+1)}{2}$$ $$\\frac{n(n+1)(n+2)}{6}$$ ","date":"2023-09-14T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"数据结构与时间复杂度"},{"content":" Object 类的主要方法\nNO. 方法名称 类型 描述 1 public Object{} 构造 构造方法 2 public boolean equal（Object obj） 普通 对象比较 3 public int hashcode（） 普通 取得 hash 值 4 public String toString（） 普通 对象在打印时调用地址 ","date":"2022-09-18T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/object%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95/","title":"Object类的主要方法"},{"content":" java 的四种访问权限修饰符\n修饰符 类内部 同一个包 子类 同一个包 private Yes default Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes ","date":"2022-09-18T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/","title":"四种访问权限修饰符"},{"content":"常用快捷键 介绍快捷键 快捷键 补全代码 alt+/R 快速修复 ctrl+1 自动导包 ctrl+shift+o 单行注释 ctrl+/ 多行注释 ctrl+shiflt+/ 删除指定行的代码 ctrl+d 上下移动代码 alt+down alt+up 切换到下一行代码空位 shiflt+enter 切换到上一行代码空位 ctrl+shiflt+enter 光标选中指定的类，查看继承树结构 ctrl+t 自动调整代码格式 ctrl+shift+F 在当前类中，显示类的结构，并支持搜索指定的方法、方法等 ctrl+o 批量修改制定的变量名、方法名、类名等 alt+shift+r 选中的结构的大小写切换：变成大写 ctrl+shift+x 选中的结构大小写切换：变成小写 ctrl+shift+y 调出生成 getter/setter/构造器等结构 alt+shift+s 显示当前选择资源（工程 or 文件）的属性 alt+enter 快速查找定位到下一个 ctrl+k 查看指定的结构使用过的地方 ctrl+alt+g ","date":"2022-09-10T00:00:00Z","image":"https://MindaRyn1.github.io/p/eclipse%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/01_hub221be157753c6895f81daad9e8b1096_46770_120x120_fill_q75_box_smart1.jpg","permalink":"https://MindaRyn1.github.io/p/eclipse%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","title":"Eclipse使用心得"},{"content":"基本概念 常用命令 git init 1 git init # 初始化本地git仓库（创建新仓库） git config 1 2 3 4 5 6 7 8 git config --global user.name \u0026#34;xxx\u0026#34; # 配置用户名 git config --global user.email \u0026#34;xxx@xxx.com\u0026#34; # 配置邮件 git config --global color.ui true # git status 等命令自动着色 git config --global color.status auto git config --global color.diff auto git config --global color.branch auto git config --global color.interactive auto git config --global --unset http.proxy # remove proxy configuration on git git clone 1 git clone xxxxx.git # clone 远程仓库 git status 1 git status # 查看当前版本状态（是否修改） git add 1 2 git add xyz # 添加 xyz 文件至 index git add . # 增加当前子目录下所有更改过的文件至 index git commit 1 2 3 git commit -m \u0026#39;xxx\u0026#39; # 提交 git commit --amend -m \u0026#39;xxx\u0026#39; # 合并上一次提交（用于反复修改） git commit -am \u0026#39;xxx\u0026#39; # 将 add 和 commit 合为一步 git rm 1 2 git rm xxx # 删除 index 中的文件 git rm -r \\* # 递归删除 git log 1 2 3 4 5 6 git log # 显示提交日志 git log -1 # 显示 1 行日志 -n 为 n 行 git log -5 git log --stat # 显示提交日志及相关变动文件 git log -p -m git log v2.0 # 显示 v2.0 的日志 git show 1 2 3 4 5 6 7 git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容 git show dfb02 # 可只用 commitid 的前几位 git show HEAD # 显示 HEAD 提交日志 git show HEAD^ # 显示 HEAD 的父（上一个版本）的提交日志 ^^为上两个版本 ^5 为上 5 个版本 git show v2.0 # 显示 v2.0 的日志及详细内容 git show-branch # 图示当前分支历史 git show-branch --all # 图示所有分支历史 git tag 1 2 git tag # 显示已存在的 tag git tag -a v2.0 -m \u0026#39;xxx\u0026#39; # 增加 v2.0 的 tag git diff 1 2 3 4 5 6 git diff # 显示所有未添加至 index 的变更 git diff --cached # 显示所有已添加 index 但还未 commit 的变更 git diff HEAD^ # 比较与上一个版本的差异 git diff HEAD -- ./lib # 比较与 HEAD 版本 lib 目录的差异 git diff origin/master..master # 比较远程分支 master 上有本地分支 master 上没有的 git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容 git remote 1 git remote add origin xxxxxxx.git # 增加远程定义（用于 push/pull/fetch） git branch 1 2 3 4 5 6 7 8 9 git branch # 显示本地分支 git branch --contains 50089 # 显示包含提交 50089 的分支 git branch -a # 显示所有分支 git branch -r # 显示所有原创分支 git branch --merged # 显示所有已合并到当前分支的分支 git branch --no-merged # 显示所有未合并到当前分支的分支 git branch -m master master_copy # 本地分支改名 git branch -d hotfixes/BJVEP933 # 删除分支 hotfixes/BJVEP933（本分支修改已合并到其他分支） git branch -D hotfixes/BJVEP933 # 强制删除分支 hotfixes/BJVEP933 git checkout 1 2 3 4 5 6 7 git checkout -b master_copy # 从当前分支创建新分支 master_copy 并检出 git checkout -b master master_copy # 上面的完整版 git checkout features/performance # 检出已存在的 features/performance 分支 git checkout --track hotfixes/BJVEP933 # 检出远程分支 hotfixes/BJVEP933 并创建本地跟踪分支 git checkout v2.0 # 检出版本 v2.0 git checkout -b devel origin/develop # 从远程分支 develop 创建新本地分支 devel 并检出 git checkout -- README # 检出 head 版本的 README 文件（可用于修改错误回退） git merge 1 git merge origin/master # 合并远程 master 分支至当前分支 git push 1 2 3 git push origin master # 将当前分支 push 到远程 master 分支 git push origin :hotfixes/BJVEP933 # 删除远程仓库的 hotfixes/BJVEP933 分支 git push --tags # 把所有 tag 推送到远程仓库 git fetch 1 2 git fetch # 获取所有远程分支（不更新本地分支，另需 merge） git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支 git pull 1 git pull origin master # 获取远程分支 master 并 merge 到当前分支 git mv 1 git mv README README2 # 重命名文件 README 为 README2 git reset 1 git reset --hard HEAD # 将当前版本重置为 HEAD（通常用于 merge 失败回退） git stash 1 2 3 4 git stash # 暂存当前修改，将所有至为 HEAD 状态 git stash list # 查看所有暂存 git stash show -p stash@{0} # 参考第一次暂存 git stash apply stash@{0} # 应用第一 ","date":"2022-09-10T00:00:00Z","image":"https://MindaRyn1.github.io/p/git%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/01_hub7d014d9b421696623b4f6a853f01c55_18928_120x120_fill_q75_box_smart1.jpg","permalink":"https://MindaRyn1.github.io/p/git%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","title":"git使用心得"},{"content":"常用快捷键 ctrl\n快捷键 介绍 ctrl+鼠标左键 查看源码 ctrl+Z 撤销 ctrl+O 重写方法 ctrl+F 在当前文件进行文本查找 ctrl+R 在当前文件进行文本替换 ctrl+F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 ctrl+F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 shift\n快捷键 介绍 shift+F9 Debug shift+F10 Run shift+F9 Debug shift+F11 弹出书签显示层 shift+Tab 取消缩进 ctrl+Alt\n快捷键 介绍 ctrl+Alt+L 格式化代码 ctrl+Alt+O 优化导入的类，可以对当前文件和整个包目录使用 ctrl+Alt+S 打开 IntelliJ IDEA 系统设置 ctrl+Alt+Enter 光标所在行上空出一行，光标定位到新行 ctrl+Alt+\u0026lt;-/-\u0026gt; 退回/前进到上一个操作的地方 ctrl+Shift\n快捷键 介绍 ctrl+Shift+Z 取消撤销 ctrl+Shift+U 对选中的代码进行大 / 小写轮流转换 ctrl+Shift 打开 IntelliJ IDEA 系统设置 其他\n快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 F11 添加书签 Tab 缩进 Debug 模式鼠标左键 打断点 常见文件类型图标 ","date":"2022-09-10T00:00:00Z","image":"https://MindaRyn1.github.io/p/idea%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/02_hu8b45880e7f4a3e24b6f3233a0590de7a_10053_120x120_fill_q75_box_smart1.jpg","permalink":"https://MindaRyn1.github.io/p/idea%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/","title":"IDEA使用心得"},{"content":" java.lang java 语言的核心类 如 String Math Integer\njava.net 网络操作的类和接口\njava.io 输入输出类\nava.util 实用工具类，定义系统特性，接口集合框架\njava.text java 格式化相关类\njava.sql java 进行 JDBC 相关类，接口\njava.swt 抽象窗口工具集类 GUI\njava.applet applet 运行类\n","date":"2022-09-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/jdk%E4%B8%AD%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8C%85%E4%BB%8B%E7%BB%8D/","title":"JDK中主要的包介绍"},{"content":"##正文\n","date":"2022-09-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E5%85%B3%E9%94%AE%E5%AD%97/","title":"关键字"},{"content":" java 类及类的成员 面向对象的三大特征 其他关键字\n","date":"2022-09-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象"},{"content":" java 类及类的成员 面向对象的三大特征 其他关键字\n","date":"2022-09-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","title":"面向对象"},{"content":" 一维数组 多维数组\n","date":"2022-09-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":" 算数运算符 逻辑运算符 位运算符\n","date":"2022-09-10T00:00:00Z","permalink":"https://MindaRyn1.github.io/p/%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"运算符"}]